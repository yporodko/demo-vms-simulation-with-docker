####### Global Parameters #########

debug=2
log_stderror=yes
log_facility=LOG_LOCAL0

fork=yes
children=4

listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

####### Modules Section ########

mpath="/usr/lib/aarch64-linux-gnu/kamailio/modules/"

# Core modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "dispatcher.so"

# ----------------- setting module-specific parameters ---------------

# ----- tm params -----
modparam("tm", "fr_timer", 10000)
modparam("tm", "fr_inv_timer", 30000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)

# ----- dispatcher params -----
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_mode", 1)

####### Routing Logic ########

request_route {

    # per request initial checks
    route(REQINIT);

    # handle requests within SIP dialogs
    route(WITHINDLG);

    # handle registrations (we don't handle registrations, just forward)
    # route(REGISTRAR);

    # handle presence (we don't handle presence, just forward)
    # route(PRESENCE);

    # dispatch to asterisk servers
    route(DISPATCH);

    route(RELAY);
}

# Handle initial request routing
route[REQINIT] {
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(msg:len > 2048) {
        sl_send_reply("513", "Message too big");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # sequential request within a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("BYE")) {
            # handle BYE
            xlog("L_INFO", "BYE received\n");
        } else if (is_method("INVITE")) {
            # handle re-INVITE
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        } else {
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Dispatch to Asterisk backend servers
route[DISPATCH] {
    # round robin dispatching on gateways group 1
    # group 1 contains both asterisk servers with weights
    if(!ds_select_dst("1", "9")) {
        send_reply("503", "Service Unavailable");
        exit;
    }

    xlog("L_INFO", "--- Dispatching call to $du (from $si:$sp)\n");

    # record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    return;
}

# Relay to destination
route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Response handling
onreply_route {
    xlog("L_INFO", "--- Response received: $rs $rr\n");
}

# Failure handling
failure_route {
    if (t_is_canceled()) {
        exit;
    }

    # uncomment the following lines if you want to block client
    # redirect based on 3xx replies.
    ##if (t_check_status("3[0-9][0-9]")) {
    ##      t_reply("404","Not found");
    ##      exit;
    ##}
}
